# godot-benchmark-gdscript-csharp

Godot中gdscript与C#的性能之争一直是一个经久不衰的话题，因此本项目致力于探究gdscript与C#究竟谁快。

根据官方所说：
> the performance of C# in Godot — while generally in the same order of magnitude — is roughly ~4× that of GDScript in some naive cases. C++ is still a little faster; the specifics are going to vary according to your use case. GDScript is likely fast enough for most general scripting workloads.

语言|描述|毫秒|运行次数|语言|描述|毫秒|运行次数
---|---|---|---|---|---|---|---
gds|循环|117|10000000|c#|循环|2|10000000
gds|字典读写（整数）|1834|10000000|c#|字典读写（整数，使用Godot字典）|1921|10000000
|||||c#|字典读写（整数，使用C#字典）|90|10000000
gds|转换成字符串|1535|10000000|c#|转换成字符串|80|10000000
gds|字典读写（字符串）|10.08625|100000|c#|字典读写（字符串，使用Godot字典）|34.29627|100000
|||||c#|字典读写（字符串，使用C#字典）|9.42627|100000
gds|新建并添加Node|13.191032|10000|c#|新建并添加Node|21.848601|10000
gds|函数调用（同语言内）|489|10000000|c#|函数调用（同语言内）|1.216|10000000
gds|函数调用（调用父节点的GDS函数）|498|10000000|c#|函数调用（调用父节点的GDS函数）|6456.471|10000000
gds|函数调用（调用C#节点的函数）|326|10000000|c#|函数调用（调用C#节点的函数）|1.849|10000000
|||||c#|函数调用（调用C#节点的函数，使用字符串Call）|6237.303|10000000
gds|发送信号到GD节点|2078|10000000|c#|发送信号到GD节点|7196.842|10000000
gds|修改node3d position|407|10000000|c#|修改node3d position|179.722|10000000
gds|遍历大型GD字典|47|1|c#|遍历大型GD字典|202|1
gds|传递大型字符串|0|1|c#|传递大型字符串|55|1

> 注意：循环项统计了10000000次迭代的循环本身的耗时，并且在循环中对一个变量赋值以防止可能的编译器优化。其他调用次数大于1的，都按比例扣除了循环本身的耗时。最终结果使用导出模板导出后测试，模拟实际游戏情况。
> 
> 本项目目前主要测试了涉及节点交互的内容，纯数学计算无疑是C#快相当多倍。其他各种API基于实现的不同暂时未进行测试，欢迎贡献。

## 结果分析
### 一、循环
仅仅循环本身，gds会浪费大量的时间在迭代上，因此如果有大量数据要进行遍历运算，使用C#可以达到相当好的加速。

### 二、字典读写
字典读写中，每次均进行5000000次写500000次读，以衡量字典的综合性能。
可以看到，在读写Godot内置的字典类型时，如果以整数为键，GDS和C#的表现相当，虽然都不快。如果C#端使用C#内置的字典性能自然相当好，但是也抛弃了Godot的数据类型。

如果字符串作为键，显然会更耗时，因此仅遍历10000次，那么相对来说，gds的字典表现令人惊讶的快，几乎相等于C#原生字典，而在C#中使用GD字典性能会更差。（在统计中均扣除了数字转字符串的开销，因为通常使用中并不会将大量数字转换成字符串作为键，而是直接使用字符串作为键）

### 三、新建并添加节点
gds显然更快，但并没有数量级的差距。

### 四、函数调用
同节点内的调用，C#有着相当大的优势，而GDS的调用看上去就相当慢了，这个问题会特别影响例如递归的场景。而调用其他GDS节点的时候，gds拥有调用原生GDS函数的性能。GDS调用C#居然会比直接调用GDS函数更快。而C#端调用GDS函数性能就相当不容乐观，估计问题出在字符串函数名上。C#端如果通过字符串调用同为C#的节点时，性能会相当相当差，但如果通过`as`强制转换为C#类型，直接调用函数的话，性能相当好。因此这是推荐的用法！

### 五、信号
GDS发送信号到GDS触发一个函数，性能比直接调用函数差4倍，而C#端发送信号到GDS端，性能同样相当差，估计也是因为通过字符串查找的原因。没有触发C#端信号的数据，因为在测试中，多调用几次就直接报错，无法使用。

### 六、修改Node3D的位置
令人惊讶的是，C#的性能快了GDS一倍，虽然没有任何计算内容。

### 七、遍历大型字典
对于GDS的字典进行遍历，GDS的性能远好于C#端，可能C#端在创建可变数据类型浪费了太多性能。

### 八、传递字符串
GDS内部传递字符串只是一个引用，所以不需要时间，但大型字符串传递到C#中，会需要不少时间，需要注意。

## 总结
总的来说，纯C#的部分C#的性能遥遥领先，没有悬念。但如果涉及到引擎API，有的API会更慢，有的API会更快，取决于具体的实现。对于C#来说，如果充分利用GD的可变数据类型，将会极大地影响性能，所以应该尽可能使用原生C#的数据类型，在完成一切运算后，再调用引擎的API，而不是像GDS一样，把GD的数据类型当作日常使用的数据类型，这样会失去使用C#的好处。

如果节点全是C#，那么合理的调用会极大的减少函数调用的成本；如果C#和GDS混用，注意不要相互频繁调用。

## 更多场景
- 实例化TSCN
- 变量赋值的开销
- ...